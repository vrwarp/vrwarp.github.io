<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/core-ajax/core-ajax.html">
<link rel="import" href="../bower_components/core-localstorage/core-localstorage.html">
<link rel="import" href="gdrive-data.html">
<link rel="import" href="localforage-cache.html">
<script type="text/javascript" src="utils.js"></script>

<polymer-element name="manga-list-data" attributes="loading progress">
  <template>
    <gdrive-data
       id="driveData"
       modelReady="{{driveModelReady}}"></gdrive-data>
    <core-ajax id="ajax" handleAs="json"></core-ajax>
  </template>
  <script>
    (function() {
        var initialized_ = false;
        var manga_ = {};
        var starredManga_ = new Set();
        localforage.getItem(MANGA_STARRED).then(function (value) {
            if (!value || starredManga_.size > 0) {
                return;
            }

            console.log("Loading starred manga from cache");
            starredManga_ = new Set(value);
            for (var i = 0; i < instanceKeys_.length; i++) {
                var key = instanceKeys_[i];
                if (instanceMap_.has(key)) {
                    instanceMap_.get(key).updateStarred_();
                }
            }
        });
        var latestReadDateMap_ = new Map();

        var nextInstanceId_ = 0;
        var instanceKeys_ = [];
        var instanceMap_ = new WeakMap();
        var addInstance_ = function (instance) {
            for (var i = 0; i < instanceKeys_.length; i++) {
                if (!instanceMap_.has(instanceKeys_[i])) {
                    instanceMap_.set(instanceKeys_[i], instance);
                    return;
                }
            }
            var key = {id: nextInstanceId_++};
            instanceKeys_.push(key);
            instanceMap_.set(key, instance);;
        }
        var notifyInstances_ = function (event, msg) {
            for (var i = 0; i < instanceKeys_.length; i++) {
                var key = instanceKeys_[i];
                if (instanceMap_.has(key)) {
                    instanceMap_.get(key).fire(event, msg);
                }
            }
        }
        var updatePropertyOfInstances_ = function (property, value) {
            for (var i = 0; i < instanceKeys_.length; i++) {
                var key = instanceKeys_[i];
                if (instanceMap_.has(key)) {
                    instanceMap_.get(key)[property] = value;
                }
            }
        }

        var convertHTMLEntitiesToString_ = function (text) {
            var temp = document.createElement('p');
            temp.innerHTML = text.replace("<", "&lt;").replace(">", "&gt;");
            return temp.textContent;
        }

        var convertToExpectedMangaModel_ = function (model) {
            return {
                title: convertHTMLEntitiesToString_(model.t),
                id: model.i,
                image: model.im ? "https://cdn.mangaeden.com/mangasimg/" + model.im : undefined,
                latestChapterDate: model.ld,
                starred: starredManga_.has(model.i),
                hasUnreadChapters: latestReadDateMap_.has(model.i) &&
                    model.ld > latestReadDateMap_.get(model.i),
            };
        }

        var updateManga_ = function (manga) {
            manga.forEach(function (model) {
                if (model.id in manga_) {
                    var original = manga_[model.id];
                    var updated = false;
                    // Maybe update all the fields of model.
                    for (key in model) {
                        if (original[key] != model[key]) {
                            original[key] = model[key];
                            updated = true;
                        }
                    }
                    if (updated) {
                        notifyInstances_("update-manga", model.id);
                    }
                } else {
                    manga_[model.id] = model;
                    notifyInstances_("new-manga", model);
                }
            });

            // Cache the updated value.
            localforage.setItem(MANGA_MANGA, manga_);
            localforage.setItem(CACHE_VERSION, CURRENT_CACHE_VERSION);
        }

        var cacheLength_ = -1;
        localforage.getItem(MANGA_RESPONSE_SIZE).then(function(value) {
            cacheLength_ = value;
        });
        var refreshMangaProgressEvent_ = function(event) {
            var percent = -1;
            if (event.lengthComputable) {
                percent = event.loaded / event.total;
            } else if (cacheLength_ > event.loaded) {
                percent = event.loaded / cacheLength_;
            }
            updatePropertyOfInstances_("progress", percent);
        }

        var refreshMangaLoadEndEvent_ = function(event) {
            updatePropertyOfInstances_("progress", 2);
            localforage.setItem(MANGA_RESPONSE_SIZE, event.loaded);
        }

        var refreshManga_ = function() {
            return getJsonUrl(
                "https://cors-anywhere.herokuapp.com/www.mangaeden.com/api/list/0/",
                function (req) {
                    req.addEventListener("progress", refreshMangaProgressEvent_, false);
                    req.addEventListener("loadend", refreshMangaLoadEndEvent_, false);
                }).then(function (data) {
                    updateManga_(data.manga.map(convertToExpectedMangaModel_));
                });
        }

        var initialRefresh = refreshManga_();
        var fetchFromCache = Promise.all([
            localforage.getItem(CACHE_VERSION),
            localforage.getItem(MANGA_MANGA)]).then(function(values) {
                if (values[0] != CURRENT_CACHE_VERSION || !values[1]) {
                    return Promise.reject();
                }
                
                console.log("Loaded manga from cache.");
                manga_ = values[1];
            }).catch(function () {
                return initialRefresh;
            });
        Promise.race([initialRefresh, fetchFromCache]).then(function () {
            initialized_ = true;
            for (var i = 0; i < instanceKeys_.length; i++) {
                var key = instanceKeys_[i];
                if (instanceMap_.has(key)) {
                    var instance = instanceMap_.get(key);
                    instance.loading = false;
                    instance.mangaListLoaded_();
                }
            }
        });

        Polymer({
            loading: !initialized_,
            progress: 2,
            domReady: function() {
                addInstance_(this);
                if (initialized_) {
                    this.mangaListLoaded_();
                }
            },
            mangaListLoaded_: function() {
                this.fire("manga-list-loaded", this.getMangaList());
            },
            ascendingTitle: function (a,b) {
                if (a.starred && !b.starred) {
                    return -1;
                }
                if (!a.starred && b.starred) {
                    return 1;
                }

                if (a.hasUnreadChapters && !b.hasUnreadChapters) {
                    return -1;
                }
                if (!a.hasUnreadChapters && b.hasUnreadChapters) {
                    return 1;
                }

                if (a.title < b.title) {
                    return -1;
                }
                if (a.title > b.title) {
                    return 1;
                }

                return 0;
            },
            getMangaList: function() {
                var result = [];
                for (var key in manga_) {
                    result.push(manga_[key]);
                }
                result.sort(this.ascendingTitle.bind(this));
                return result;
            },
            driveModelReadyChanged: function (oldvalue, newvalue) {
                this.updateStarred_();
                this.updateLatestReadDateMap_();
                this.mangaListLoaded_();
            },
            updateStarred_: function() {
                if (this.driveModelReady) {
                    starredManga_ = this.$.driveData.getStarredManga();

                    var starredMangaList = [];
                    starredManga_.forEach(function (value) { starredMangaList.push(value); });
                    localforage.setItem(MANGA_STARRED, starredMangaList);
                }
                for (var key in manga_) {
                    manga_[key].starred = starredManga_.has(key);
                }
            },
            updateLatestReadDateMap_: function() {
                latestReadDateMap_ = this.$.driveData.getLatestReadChapterDateMap();
                for (var key in manga_) {
                    manga_[key].hasUnreadChapters = latestReadDateMap_.has(key) &&
                        manga_[key].latestChapterDate > latestReadDateMap_.get(key);
                }
            },
        });
    })();
  </script>
</polymer-element>
