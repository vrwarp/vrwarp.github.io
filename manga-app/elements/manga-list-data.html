<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/core-ajax/core-ajax.html">
<link rel="import" href="../bower_components/core-localstorage/core-localstorage.html">
<link rel="import" href="gdrive-data.html">
<script type="text/javascript" src="../bower_components/localforage/dist/localforage.js"></script>

<polymer-element name="manga-list-data" attribute="loading">
  <template>
		<gdrive-data
			 id="driveData"
			 modelReady="{{driveModelReady}}"></gdrive-data>
		<core-ajax id="ajax" handleAs="json"></core-ajax>
  </template>
	<script>
		(function() {
				var initialized_ = false;
				var manga_ = {};
				var starredManga_ = new Set();
				var latestReadDateMap_ = new Map();
				var CACHE_VERSION = 1;

				var nextInstanceId_ = 0;
				var instanceKeys_ = [];
				var instanceMap_ = new WeakMap();
				var addInstance_ = function (instance) {
						for (var i = 0; i < instanceKeys_.length; i++) {
								if (!instanceMap_.has(instanceKeys_[i])) {
										instanceMap_.set(instanceKeys_[i], instance);
										return;
								}
						}
						var key = {id: nextInstanceId_++};
						instanceKeys_.push(key);
						instanceMap_.set(key, instance);;
				}
				var notifyInstances_ = function (event, msg) {
						for (var i = 0; i < instanceKeys_.length; i++) {
								var key = instanceKeys_[i];
								if (instanceMap_.has(key)) {
										instanceMap_.get(key).fire(event, msg);
								}
						}
				}

				var getUrl_ = function (url) {
						// Return a new promise.
						return new Promise(function(resolve, reject) {
								// Do the usual XHR stuff
								var req = new XMLHttpRequest();
								req.open('GET', url);
								
								req.onload = function() {
										// This is called even on 404 etc
										// so check the status
										if (req.status == 200) {
												// Resolve the promise with the response text
												resolve(req.response);
										}
										else {
												// Otherwise reject with the status text
												// which will hopefully be a meaningful error
												reject(Error(req.statusText));
										}
								};
								
								// Handle network errors
								req.onerror = function() {
										reject(Error("Network Error"));
								};
								
								// Make the request
								req.send();
						});
				}

				var getJsonUrl_ = function (url) {
						return getUrl_(url).then(function (response) {
								try {
										return JSON.parse(response);
								} catch (x) {
										console.warn('getJsonUrl_ caught an exception trying to parse response as JSON:');
										console.warn('url:', url);
										console.warn(x);
										return Promise.reject(x);
								}
						});
				}

				var convertHTMLEntitiesToString_ = function (text) {
						var temp = document.createElement('p');
						temp.innerHTML = text.replace("<", "&lt;").replace(">", "&gt;");
						return temp.textContent;
				}

				var convertToExpectedMangaModel_ = function (model) {
						return {
								title: convertHTMLEntitiesToString_(model.t),
								id: model.i,
								image: model.im ? "https://cdn.mangaeden.com/mangasimg/" + model.im : undefined,
								latestChapterDate: model.ld,
								starred: starredManga_.has(model.i),
								hasUnreadChapters: latestReadDateMap_.has(model.i) &&
										model.ld > latestReadDateMap_.get(model.i),
						};
				}

				var updateManga_ = function (manga) {
						manga.forEach(function (model) {
								if (model.id in manga_) {
										var original = manga_[model.id];
										var updated = false;
										// Maybe update all the fields of model.
										for (key in model) {
												if (original[key] != model[key]) {
														original[key] = model[key];
														updated = true;
												}
										}
										if (updated) {
												notifyInstances_("update-manga", model.id);
										}
								} else {
										manga_[model.id] = model;
										notifyInstances_("new-manga", model);
								}
						});

						// Cache the updated value.
						localforage.setItem("manga", manga_);
						localforage.setItem("version", CACHE_VERSION);
				}

				var refreshManga_ = function() {
						return getJsonUrl_("https://cors-anywhere.herokuapp.com/www.mangaeden.com/api/list/0/").then(
								function (data) {
										updateManga_(data.manga.map(convertToExpectedMangaModel_));
								});
				}

				var initialRefresh = refreshManga_();
				var fetchFromCache = Promise.all([
						localforage.getItem("version"),
						localforage.getItem("manga")]).then(function(values) {
								if (values[0] != CACHE_VERSION || !values[1]) {
										return Promise.reject();
								}
								
								console.log("Loaded manga from cache.");
								manga_ = values[1];
						}).catch(function () {
								return initialRefresh;
						});
				Promise.race([initialRefresh, fetchFromCache]).then(function () {
						initialized_ = true;
						for (var i = 0; i < instanceKeys_.length; i++) {
								var key = instanceKeys_[i];
								if (instanceMap_.has(key)) {
										var instance = instanceMap_.get(key);
										instance.loading = false;
										instance.mangaListLoaded_();
								}
						}
				});

				Polymer({
						loading: !initialized_,
						domReady: function() {
								addInstance_(this);
								if (initialized_) {
										this.mangaListLoaded_();
								}
						},
						mangaListLoaded_: function() {
								this.fire("manga-list-loaded", this.getMangaList());
						},
						ascendingTitle: function (a,b) {
								if (a.starred && !b.starred) {
										return -1;
								}
								if (!a.starred && b.starred) {
										return 1;
								}

								if (a.hasUnreadChapters && !b.hasUnreadChapters) {
										return -1;
								}
								if (!a.hasUnreadChapters && b.hasUnreadChapters) {
										return 1;
								}

								if (a.title < b.title) {
										return -1;
								}
								if (a.title > b.title) {
										return 1;
								}

								return 0;
						},
						getMangaList: function() {
								var result = [];
								for (var key in manga_) {
										result.push(manga_[key]);
								}
								result.sort(this.ascendingTitle.bind(this));
								return result;
						},
						driveModelReadyChanged: function (oldvalue, newvalue) {
								this.updateStarred_();
								this.updateLatestReadDateMap_();
								this.mangaListLoaded_();
						},
						updateStarred_: function() {
								starredManga_ = this.$.driveData.getStarredManga();
								for (var key in manga_) {
										manga_[key].starred = starredManga_.has(key);
								}
						},
						updateLatestReadDateMap_: function() {
								latestReadDateMap_ = this.$.driveData.getLatestReadChapterDateMap();
								for (var key in manga_) {
										manga_[key].hasUnreadChapters = latestReadDateMap_.has(key) &&
												manga_[key].latestChapterDate > latestReadDateMap_.get(key);
								}
						},
				});
		})();
	</script>
</polymer-element>
